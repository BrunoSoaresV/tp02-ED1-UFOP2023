\documentclass{article}

\input{setup}

\begin{document}

\CAPA{Trabalho Prático II (TP II)}{BCC202 – Estruturas de Dados I}{Bruno Soares Veríssimo}{Pedro Silva}


\section{Introdução}


Para este trabalho é necessário entregar o código em C e um relatório referente ao que foi desenvolvido. O algoritmo a ser desenvolvido é o caixeiro viajante.

A codificação deve ser feita em C, usando somente a biblioteca padrão da GNU, sem o uso de bibliotecas adicionais. Além disso, deve-se usar um dos padrões: ANSI C 89 ou ANSI C 99.

\subsection{Especificações do problema}

O Trabalho Prático II, propõe a resolução do Problema do Caixeiro Viajante. Neste cenário, um caixeiro deve visitar um conjunto de cidades distintas, começando e terminando na primeira cidade. O objetivo é determinar a trajetória que resulta na menor distância total de viagem. O trabalho exige a implementação de um algoritmo que utilize recursividade e listas de adjacências para encontrar o menor caminho possível passando por todas as cidades, partindo da cidade inicial.

\subsection{Considerações iniciais}

Algumas ferramentas foram utilizadas durante a criação deste projeto:

\begin{itemize}
  \item Ambiente de desenvolvimento do código fonte: Visual Studio Code. \footnote{Visual Studio Code está disponível em \url{https://code.visualstudio.com/}}
  \item Linguagem utilizada: C.
  \item Ambiente de desenvolvimento da documentação: Overleaf \LaTeX. \footnote{Disponível em \url{https://www.overleaf.com/}}
\end{itemize}

\subsection{Ferramentas utilizadas}
Algumas ferramentas foram utilizadas para testar a implementação, como:
\begin{itemize}
    \item[-] \textit{CLANG}: ferramentas de análise estática do código.
    \item[-] \textit{Valgrind}: ferramentas de análise dinâmica do código.
\end{itemize}

\subsection{Especificações da máquina}
A máquina onde o desenvolvimento e os testes foram realizados possui a seguinte configuração:
\begin{itemize}
    \item[-] Processador:  Intel® Core™ i5-10300H.
    \item[-] Memória RAM: 24Gb.
    \item[-] Sistema Operacional: Windows 10.
\end{itemize}

\subsection{Instruções de compilação e execução}

Para a compilação do projeto, basta digitar:

\begin{tcolorbox}[title=Compilando o projeto,width=\linewidth]
    gcc main.c grafo.c -o exe -std=c99 -Wall -pg -g
\end{tcolorbox}

Usou-se para a compilação as seguintes opções:
\begin{itemize}
    \item [-] \emph{-std=99}: para usar-se o padrão ANSI C 99, conforme exigido.
    \item [-] \emph{-g}: para compilar com informação de depuração e ser usado pelo Valgrind.
    \item [-] \emph{-Wall}: para mostrar todos os possível \emph{warnings} do código.
    \item [-] \emph{-pg}: para gerar o arquivo para fazer-se o profiling para identificar gargalos no programa.
\end{itemize}

Para a execução do programa basta digitar:
\begin{tcolorbox}[title=,width=\linewidth]
    ./exe caminho\_até\_o\_arquivo\_de\_entrada opcao
\end{tcolorbox}

Onde ``opcao'' pode ser: ``p'' para fazer a, ``d'' para fazer b e ``n'' para fazer c.

\section{Desenvolvimento}
O Trabalho Prático II é um trabalho muito parecido com o Trabalho Prático I. Ambos buscam a solução do problema do caixeiro viajante, Todavia dessa vez além de calcular o melhor caminho, deve-se usar listas de adjacências para representar os vizinhos de cada cidade, essas listas devem ser implementadas utilizando listas encadeadas, devem ser ordenadas e usadas para o cálculo do melhor caminho e da menor distância. 

\subsection{Criando as estruturas necessárias}
 Primeiramente foi necessário criar as estruturas No, que possuí o destino do nó, o peso da aresta que conecta o nó ao seu destino e o ponteiro para o próximo nó na lista, a estrutura  ListaAdj, que possuí um ponteiro para a cabeça da lista de adjacência e a estrutura GrafoPonderado, que possuí o número de cidades no grafo e o vetor de listas de adjacência para cada cidade. Além disso, foi inicializado as funções alocarGrafo, desalocarGrafo, leGrafo, encontraCaminho, imprimeCaminho, ordenaLista, imprimeOrdenado e obterDistancia em grafo.h.
\begin{lstlisting}[caption={grafo.h},label={lst:cod1},language=C]
#ifndef GRAFO_H
#define GRAFO_H

// Definição da estrutura No, representando um nó em uma lista de adjacência.
typedef struct No {
    int destino;        // Armazena o destino do nó (vértice adjacente).
    int peso;           // Armazena o peso da aresta que conecta o nó ao seu destino.
    struct No* proximo;  // Ponteiro para o próximo nó na lista.
} No;

// Definição da estrutura ListaAdj, representando uma lista de adjacência para um vértice em um grafo ponderado.
typedef struct ListaAdj {
    No* cabeca;  // Ponteiro para a cabeça da lista de adjacência.
} ListaAdj;

// Definição da estrutura GrafoPonderado, representando um grafo ponderado.
typedef struct GrafoPonderado {
    int numCidades;         // Número de cidades no grafo.
    ListaAdj* listaAdjacencia;  // Vetor de listas de adjacência para cada cidade.
} GrafoPonderado;

// Protótipos das funções definidas no arquivo "grafo.c".
GrafoPonderado* alocarGrafo(int numCidades);
void desalocarGrafo(GrafoPonderado* grafo);
void leGrafo(GrafoPonderado* grafo);
void encontraCaminho(GrafoPonderado* grafo, int* melhorCaminho);
void imprimeCaminho(GrafoPonderado* grafo, int* caminho, int distancia);
void ordenaLista(GrafoPonderado* grafo);
void imprimeOrdenado(GrafoPonderado* grafo);
int obterDistancia(GrafoPonderado* grafo, int cidadeOrigem, int cidadeDestino);

#endif

\end{lstlisting}
\subsection{Resolução do problema}
Após a criação das estruturas é necessário aloca-las. Para isso, a função criarNo aloca memória para um novo nó de grafo, atribui valores de destino e peso ao nó e inicializa o próximo nó como NULL e retorna o nó criado. A função criarListaAdj aloca memória para uma nova lista de adjacência, inicializa a cabeça da lista como NULL e retorna a lista de adjacência criada. E a função alocarGrafo aloca memória para um novo grafo ponderado, inicializa o número de cidades e aloca memória para a lista de adjacência e retorna o grafo alocado.

A função desalocarGrafo libera a memória de todos os nós e listas de adjacência, e do próprio grafo e a função leGrafo lê do input as informações das arestas do grafo e as armazena nas listas de adjacência correspondentes.

A função obterDistancia foi projetada para encontrar a distância ou o peso de uma aresta entre duas cidades específicas em um grafo ponderado. A função começa localizando a lista de adjacência da cidade de origem. Ela faz isso acessando grafo-\textgreater listaAdjacencia[cidadeOrigem].cabeca. Este passo é crucial porque a lista de adjacência da cidade de origem contém todos os nós (ou arestas) que se conectam a outras cidades a partir da cidade de origem. A função então entra em um loop while que percorre a lista de adjacência. O loop continua enquanto o ponteiro para o nó atual (atual) não é NULL, o que significaria o fim da lista. Dentro do loop, a função verifica se o destino do nó atual (atual-\textgreater destino) é igual à cidade de destino desejada (cidadeDestino). Se corresponder, isso significa que o nó atual representa a aresta que conecta a cidade de origem à cidade de destino.
Se a cidade de destino for encontrada, a função retorna o peso (peso) da aresta correspondente. Esse peso é o valor armazenado em atual-\textgreater peso, que representa a distância ou o custo para viajar da cidade de origem para a cidade de destino. Se a cidade de destino não for encontrada no nó atual, o ponteiro atual é atualizado para o próximo nó na lista e o loop continua.
Se a função percorrer toda a lista de adjacência sem encontrar a cidade de destino, ela retorna -1. Isso indica que não há uma aresta direta conectando a cidade de origem à cidade de destino no grafo.

A função encontracaminhorec é uma função recursiva projetada para encontrar o caminho mais curto em um grafo ponderado, usando a técnica de backtracking. Ela recebe os seguintes parâmetros: posicao: Cidade atual no caminho.
distancia: Distância acumulada até o momento.
contador: Contador do número de cidades visitadas.
visitado: Array para marcar as cidades já visitadas.
caminhoAtual: Array que armazena o caminho atual.
melhorCaminho: Array para armazenar o melhor caminho encontrado.
numCidades: Número total de cidades no grafo.
grafo: Ponteiro para o grafo ponderado.
menorDistancia: Ponteiro para a menor distância encontrada.
A função primeiro verifica se todas as cidades foram visitadas. Se sim, ela busca uma aresta que retorne à cidade de origem para formar um ciclo completo. Se um ciclo completo é encontrado e sua distância total é menor que a menorDistancia conhecida, o melhorCaminho e a menorDistancia são atualizados. A função então explora recursivamente as arestas saindo da posicao atual para encontrar todas as cidades ainda não visitadas.Para cada cidade não visitada e conectada, a função marca a cidade como visitada, adiciona-a ao caminhoAtual e chama encontraCaminhoRec para a próxima cidade. Após explorar uma cidade, a função desmarca a cidade para permitir a exploração de outros caminhos.

A função encontracaminho serve como uma função auxiliar para configurar e iniciar a busca recursiva pelo caminho mais curto. Recebe como parâmetro um ponteiro para o grafo ponderado e um array para armazenar o melhor caminho encontrado. Em suma ela realiza 5 etapas: 1- Aloca memória para o array visitado e caminhoAtual. 
2-Inicializa a menorDistancia com um valor máximo. 
3-Marca a cidade de origem como visitada e inicia o caminhoAtual a partir dela.
4-Chama encontraCaminhoRec para iniciar a busca pelo caminho mais curto.
5-Após a conclusão da busca, a função libera a memória alocada para os arrays visitado e caminhoAtual.

A função imprimeCaminho no código é responsável por imprimir o melhor caminho encontrado em um grafo ponderado, juntamente com a distância total desse caminho. A função começa imprimindo a cidade de origem do caminho. Na implementação padrão para problemas de caminho mais curto, geralmente se assume que o caminho começa e termina na mesma cidade (cidade 0), formando um ciclo. Em seguida, a função entra em um loop for para percorrer todas as cidades no array caminho. Cada cidade no caminho é impressa em sequência. Este loop não inclui a última cidade do caminho, pois o caminho retorna à cidade de origem. Após imprimir todas as cidades no caminho, a função imprime novamente a cidade de origem para indicar o fechamento do ciclo. Por fim, a função imprime a distância total do caminho encontrado, que foi passada como parâmetro para a função.


A função ordenaLista no código é utilizada para ordenar as listas de adjacência de cada vértice em um grafo ponderado. Essa ordenação é feita com base no peso das arestas. A função começa com um loop for que percorre todas as cidades (ou vértices) do grafo. Para cada cidade, a função acessa sua lista de adjacência. Para cada lista de adjacência, a função primeiro verifica se a lista está vazia ou contém apenas um elemento. Em ambos os casos, a lista já está ordenada, e o loop continua para a próxima cidade. Se a lista contiver mais de um elemento, a função entra em um processo de ordenação:
Inicializa uma nova lista ordenada (listaOrdenada), inicialmente vazia.
Percorre os elementos da lista original, removendo cada elemento da lista original e inserindo-o na posição correta na lista ordenada. Para cada nó (atual) da lista original, a função determina a posição correta na lista ordenada com base no peso (peso) da aresta.
Existem dois casos para a inserção:
Inserção no Início: Se a lista ordenada estiver vazia ou se o peso do nó atual for menor ou igual ao peso do primeiro nó da lista ordenada, o nó é inserido no início da lista ordenada.
Inserção no Meio ou Fim: Caso contrário, a função procura o local correto na lista ordenada (usando um loop while) e insere o nó atual nessa posição. Após ordenar todos os nós, a cabeça da lista original é atualizada para apontar para a cabeça da lista ordenada. Isso efetivamente substitui a lista original pela lista ordenada.

E por fim temos a função imprimeOrdenado que é responsável por imprimir as listas de adjacência de cada vértice em um grafo ponderado, após serem ordenadas pela função ordenaLista. Essa impressão oferece uma visualização clara da estrutura do grafo e de como os vértices estão conectados entre si. A função começa com um loop for que percorre todos os vértices (ou cidades) do grafo. Para cada vértice, a função imprime as adjacências relacionadas a esse vértice. Para cada vértice i, a função imprime uma mensagem inicial indicando que as adjacências do vértice i serão listadas. Isso é útil para identificar a qual vértice a lista de adjacência pertence. Em seguida, a função inicia um loop while que percorre a lista de adjacência do vértice i. Dentro deste loop, cada nó da lista (representando uma aresta) é processado.
Para cada nó, a função imprime o destino da aresta (destino) e o peso da aresta (peso). Esta informação é essencial para entender como os vértices estão conectados e qual o custo associado à conexão. Após imprimir todos os nós da lista de adjacência de um vértice, a função imprime "NULL" ou uma indicação semelhante para sinalizar o final da lista de adjacência daquele vértice.
\begin{lstlisting}[caption={grafo.c},label={lst:cod1},language=C]
#include "grafo.h" // Inclui o cabeçalho "grafo.h" que contém as declarações de funções e estruturas.
#include <stdio.h> // Inclui a biblioteca padrão de entrada/saída.
#include <stdlib.h> // Inclui a biblioteca padrão de alocação de memória.
#include <limits.h> // Inclui a biblioteca que fornece constantes de limites, incluindo INT_MAX.

// Função para criar um novo nó (aresta) em um grafo ponderado.
No* criarNo(int destino, int peso) {
    // Aloca memória para um novo nó.
    No* novoNo = (No*)malloc(sizeof(No));
    // Verifica se a alocação de memória foi bem-sucedida.
    if (novoNo == NULL) {
        exit(1); // Encerra o programa com código de erro 1 em caso de falha na alocação.
    }
    // Define o campo 'destino' do novo nó com o valor fornecido como destino.
    novoNo->destino = destino;
    // Define o campo 'peso' do novo nó com o valor fornecido como peso.
    novoNo->peso = peso;
    // Inicializa o campo 'proximo' do novo nó como nulo, indicando que inicialmente não há próximo nó na lista.
    novoNo->proximo = NULL;
    // Retorna o ponteiro para o novo nó.
    return novoNo;
}

// Função para criar uma nova lista de adjacência.
ListaAdj* criarListaAdj() {
    // Aloca memória para uma nova lista de adjacência.
    ListaAdj* lista = (ListaAdj*)malloc(sizeof(ListaAdj));
    // Verifica se a alocação de memória foi bem-sucedida.
    if (lista == NULL) {
        exit(1); // Encerra o programa com código de erro 1 em caso de falha na alocação.
    }
    // Inicializa a cabeça da lista como nula.
    lista->cabeca = NULL;
    // Retorna o ponteiro para a nova lista de adjacência.
    return lista;
}


// Função para alocar dinamicamente memória para um novo grafo ponderado.
GrafoPonderado* alocarGrafo(int numCidades) {
    // Aloca memória para uma nova estrutura GrafoPonderado.
    GrafoPonderado* grafo = (GrafoPonderado*)malloc(sizeof(GrafoPonderado));
    // Verifica se a alocação de memória foi bem-sucedida.
    if (grafo == NULL) {
        exit(1); // Encerra o programa com código de erro 1 em caso de falha na alocação.
    }
    // Inicializa o número de cidades na estrutura do grafo.
    grafo->numCidades = numCidades;
    // Aloca memória para a lista de adjacência do grafo.
    grafo->listaAdjacencia = (ListaAdj*)malloc(numCidades * sizeof(ListaAdj));
    // Verifica se a alocação da lista de adjacência foi bem-sucedida.
    if (grafo->listaAdjacencia == NULL) {
        // Tratamento de erro: libera a memória alocada para a estrutura do grafo e encerra o programa com código de erro 1.
        free(grafo);
        exit(1);
    }
    // Inicializa a lista de adjacência, definindo a cabeça de cada lista como nula.
    for (int i = 0; i < numCidades; i++) {
        grafo->listaAdjacencia[i].cabeca = NULL;
    }
    return grafo;
}

// Desaloca Grafo
void desalocarGrafo(GrafoPonderado* grafo) {
    // Verifica se o ponteiro para o grafo não é nulo.
    if (grafo != NULL) {
        // Loop externo para percorrer todas as cidades do grafo.
        for (int i = 0; i < grafo->numCidades; i++) {
            // Inicializa um ponteiro para o primeiro nó na lista de adjacência da cidade atual.
            No* atual = grafo->listaAdjacencia[i].cabeca;
            // Loop interno para liberar a memória de todos os nós na lista de adjacência da cidade atual.
            while (atual != NULL) {
                // Armazena o próximo nó antes de liberar a memória do nó atual.
                No* proximo = atual->proximo;
                // Libera a memória alocada para o nó atual.
                free(atual);
                // Atualiza o ponteiro para o próximo nó na lista.
                atual = proximo;
            }
        }
        // Libera a memória alocada para a lista de adjacência.
        free(grafo->listaAdjacencia);
        // Libera a memória alocada para a estrutura GrafoPonderado.
        free(grafo);
    }
}

// Ler grafo
void leGrafo(GrafoPonderado* grafo) {
    // Obtém o número de cidades do grafo.
    int numCidades = grafo->numCidades;
    // Loop externo para percorrer todas as cidades do grafo.
    for (int i = 0; i < numCidades; i++) {
        // Loop interno para ler as distâncias entre a cidade 'i' e todas as outras cidades.
        for (int j = 0; j < numCidades; j++) {
            // Declaração das variáveis para origem, destino e distância entre as cidades.
            int origem, destino, distancia;
            // Lê os valores de origem, destino e distância da aresta entre as cidades.
            scanf("%d %d %d", &origem, &destino, &distancia);
            // Atualiza a lista de adjacência com a distância lida.
            No* novoNo = criarNo(destino, distancia);
            novoNo->proximo = grafo->listaAdjacencia[origem].cabeca;
            grafo->listaAdjacencia[origem].cabeca = novoNo;
        }
    }
}

// Função para obter a distância entre duas cidades no grafo.
int obterDistancia(GrafoPonderado* grafo, int cidadeOrigem, int cidadeDestino) {
    // Inicializa um ponteiro do tipo No, apontando para a cabeça da lista de adjacência da cidade de origem no grafo.
    No* atual = grafo->listaAdjacencia[cidadeOrigem].cabeca;
    // Inicia um loop while que continua até que o ponteiro 'atual' seja NULL, indicando o fim da lista.
    while (atual != NULL) {
        // Verifica se o nó atual na lista de adjacência é a cidade de destino.
        if (atual->destino == cidadeDestino) {
            // Se for, retorna o peso (ou distância) associado a esse nó, que é a distância até a cidade de destino.
            return atual->peso;
        }
        // Atualiza o ponteiro 'atual' para o próximo nó na lista de adjacência.
        atual = atual->proximo;
    }
    // Se a cidade de destino não for encontrada na lista de adjacência da cidade de origem, retorna -1.
    return -1;
}

// Função recursiva para encontrar o melhor caminho em um grafo ponderado usando lista de adjacência.
void encontraCaminhoRec(int posicao, int distancia, int contador, int* visitado, int* caminhoAtual, int* melhorCaminho, int numCidades, GrafoPonderado* grafo, int* menorDistancia) {
    // Verifica se todas as cidades foram visitadas (exceto a cidade de origem).
    if (contador == numCidades - 1) {
        // Procura por uma aresta que retorne à cidade de origem (posição 0) para formar um ciclo completo.
        No* vizinho = grafo->listaAdjacencia[posicao].cabeca;
        while (vizinho != NULL) {
            int cidadeDestino = vizinho->destino;
            // Se encontrarmos um ciclo completo com distância total menor que a menor distância conhecida, atualizamos o melhor caminho e a menor distância.
            if (cidadeDestino == 0 && vizinho->peso != 0 && distancia + vizinho->peso < *menorDistancia) {
                *menorDistancia = distancia + vizinho->peso;
                for (int i = 0; i < numCidades; i++) {
                    melhorCaminho[i] = caminhoAtual[i];
                }
            }
            vizinho = vizinho->proximo;
        }
        // Retorna da recursão.
        return;
    }
    // Explora as arestas saindo da posição atual para encontrar todas as cidades ainda não visitadas.
    for (No* vizinho = grafo->listaAdjacencia[posicao].cabeca; vizinho != NULL; vizinho = vizinho->proximo) {
        int proximaCidade = vizinho->destino;
        // Verifica se a próxima cidade não foi visitada e se a aresta atual não é uma aresta sem peso (peso != 0).
        if (visitado[proximaCidade] == 0 && vizinho->peso != 0) {
            // Marca a próxima cidade como visitada e adiciona ao caminho atual.
            visitado[proximaCidade] = 1;
            caminhoAtual[contador] = proximaCidade;
            // Chama a função recursivamente para a próxima cidade.
            encontraCaminhoRec(proximaCidade, distancia + vizinho->peso, contador + 1, visitado, caminhoAtual, melhorCaminho, numCidades, grafo, menorDistancia);
            // Desmarca a cidade após a chamada recursiva para permitir a exploração de outros caminhos.
            visitado[proximaCidade] = 0;
        }
    }
}

// Função para encontrar o caminho mais curto em um grafo ponderado usando força bruta.
void encontraCaminho(GrafoPonderado* grafo, int* melhorCaminho) {
    int numCidades = grafo->numCidades;
    // Aloca um array para controlar as cidades visitadas.
    int* visitado = (int*)malloc(numCidades * sizeof(int));
    // Aloca um array para rastrear o caminho atual.
    int* caminhoAtual = (int*)malloc(numCidades * sizeof(int));
    // Inicializa a menorDistancia com um valor máximo.
    int menorDistancia = INT_MAX;
    // Marca a cidade de origem (0) como visitada e inicia o caminho atual.
    for (int i = 0; i < numCidades; i++) {
        visitado[i] = 0;
    }
    visitado[0] = 1;
    caminhoAtual[0] = 0;
    // Chama a função encontraCaminhoRec para encontrar o caminho mais curto.
    encontraCaminhoRec(0, 0, 0, visitado, caminhoAtual, melhorCaminho, numCidades, grafo, &menorDistancia);
    // Libera a memória alocada para os arrays de controle.
    free(visitado);
    free(caminhoAtual);
}

// Função para imprimir o caminho mais curto encontrado e a distância total.
void imprimeCaminho(GrafoPonderado* grafo, int* caminho, int distancia) {
    // Imprime a cidade de origem (0) para iniciar o caminho.
    printf("Melhor caminho: 0 ");
    // Percorre as cidades do caminho, exceto a última, e as imprime.
    for (int i = 0; i < grafo->numCidades - 1; i++) {
        printf("%d ", caminho[i]);
    }
    // Imprime a cidade de origem (0) novamente para completar o ciclo.
    printf("0\n");
    // Imprime a distância total do caminho encontrado.
    printf("Melhor distancia: %d\n", distancia);
}

// Função para ordenar as listas de adjacência de um grafo ponderado.
void ordenaLista(GrafoPonderado* grafo) {
    // Loop externo para percorrer todas as cidades do grafo.
    for (int i = 0; i < grafo->numCidades; i++) {
        // Obtém o ponteiro para a lista de adjacência da cidade atual.
        ListaAdj* lista = &grafo->listaAdjacencia[i];
        // Verifica se a lista está vazia ou tem apenas um elemento, o que significa que já está ordenada.
        if (lista->cabeca == NULL || lista->cabeca->proximo == NULL) {
            continue; // Pula para a próxima iteração do loop se a lista já estiver ordenada.
        }
        // Inicializa uma lista temporária para armazenar os elementos ordenados.
        ListaAdj listaOrdenada;
        listaOrdenada.cabeca = NULL;
        // Percorre os elementos da lista original.
        No* atual = lista->cabeca;
        while (atual != NULL) {
            // Armazena o próximo nó antes de removê-lo da lista original.
            No* proximo = atual->proximo;
            // Insere o nó na lista ordenada.
            if (listaOrdenada.cabeca == NULL || atual->peso <= listaOrdenada.cabeca->peso) {
                // Caso especial: insere no início da lista ordenada.
                atual->proximo = listaOrdenada.cabeca;
                listaOrdenada.cabeca = atual;
            } else {
                // Procura o local correto na lista ordenada para inserir o nó.
                No* anterior = NULL;
                No* atualOrdenada = listaOrdenada.cabeca;
                while (atualOrdenada != NULL && atual->peso > atualOrdenada->peso) {
                    anterior = atualOrdenada;
                    atualOrdenada = atualOrdenada->proximo;
                }
                // Insere o nó na posição correta.
                anterior->proximo = atual;
                atual->proximo = atualOrdenada;
            }
            // Move para o próximo nó na lista original.
            atual = proximo;
        }
        // Atualiza a cabeça da lista original para apontar para a lista ordenada.
        lista->cabeca = listaOrdenada.cabeca;
    }
}
// Função para imprimir as listas de adjacência ordenada.
void imprimeOrdenado(GrafoPonderado* grafo) {
    // Loop para percorrer todos os vértices do grafo.
    for (int i = 0; i < grafo->numCidades; i++) {
        // Imprime mensagem indicando a lista de adjacências do vértice i.
        printf("Adjacencias do vertice %d: ", i);
        // Inicializa um ponteiro para o primeiro nó na lista de adjacências do vértice i.
        No* atual = grafo->listaAdjacencia[i].cabeca;
        // Loop para percorrer todos os nós na lista de adjacências do vértice i.
        while (atual != NULL) {
            // Imprime as informações do nó atual, incluindo o destino e o peso da aresta.
            printf("(%d, %d) -> ", atual->destino, atual->peso);
            // Atualiza o ponteiro para apontar para o próximo nó na lista de adjacências.
            atual = atual->proximo;
        }
        // Imprime "NULL" para indicar o final da lista de adjacências do vértice i.
        printf("NULL\n");
    }
}
\end{lstlisting}
\subsection{Execução}
O arquivo main.c é o ponto de entrada do programa que lida com grafos ponderados. A função main é o ponto de partida do programa. Ela executa as seguintes operações: 
Leitura do Número de Cidades:
scanf("%d", &numCidades);: Lê o número de cidades a partir da entrada padrão.
Alocação do Grafo:
GrafoPonderado* grafo = alocarGrafo(numCidades);: Aloca um grafo ponderado com um número especificado de cidades.
Leitura das Informações do Grafo:
leGrafo(grafo);: Lê as informações das distâncias entre as cidades e as armazena no grafo.
Ordenação das Listas de Adjacências:
ordenaLista(grafo);: Ordena as listas de adjacências do grafo.
Alocação do Melhor Caminho: int* melhorCaminho = (int*)malloc((numCidades - 1) * sizeof(int));: Aloca memória para armazenar o melhor caminho encontrado.
Encontrando o Caminho Mais Curto: encontraCaminho(grafo, melhorCaminho);: Encontra o caminho mais curto através do grafo.
Cálculo da Distância Total: Um loop for é usado para calcular a distância total percorrida ao somar as distâncias entre as cidades do caminho.
Adicionar Distância do Último para o Primeiro Vértice: distancia += obterDistancia(grafo, melhorCaminho[numCidades - 1], melhorCaminho[0]);: Adiciona a distância entre a última cidade e a cidade de origem para fechar o ciclo.
Imprimir Lista de Adjacências e Caminho: imprimeOrdenado(grafo);: Imprime a lista de adjacências ordenada.
imprimeCaminho(grafo, melhorCaminho, distancia);: Imprime o caminho mais curto encontrado e a distância total.
Liberação da Memória: free(melhorCaminho);: Libera a memória alocada para o vetor do melhor caminho.
desalocarGrafo(grafo);: Libera a memória alocada para o grafo.
Retorno da Função main: return 0;: Retorna 0 para indicar que o programa foi executado com sucesso.

O main.c gerencia o fluxo geral do programa, tratando da leitura de dados, processamento do grafo (como alocação, leitura, ordenação, busca do melhor caminho) e, finalmente, da impressão dos resultados e liberação de recursos. É a parte do programa que orquestra as operações sobre o grafo, utilizando as funções definidas em grafo.c e as estruturas definidas em grafo.h.
\begin{lstlisting}[caption={main.c},label={lst:cod1},language=C]
#include "grafo.h" // Inclui a definição das estruturas e funções do grafo.
#include <stdio.h> // Inclui a biblioteca padrão para entrada/saída.
#include <stdlib.h> // Inclui a biblioteca padrão de alocação de memória.
int main() {
    int numCidades;
    scanf("%d", &numCidades); // Lê o número de cidades a partir da entrada padrão.
    // Aloca espaço na memória para um grafo ponderado com 'numCidades'.
    GrafoPonderado* grafo = alocarGrafo(numCidades);
    // Lê as informações das distâncias entre as cidades e as armazena no grafo.
    leGrafo(grafo);
    // Ordena as listas de adjacências
    ordenaLista(grafo);
    // Aloca memória para armazenar o melhor caminho encontrado, exceto a cidade de origem.
    int* melhorCaminho = (int*)malloc((numCidades - 1) * sizeof(int));
    // Encontra o caminho mais curto através do grafo.
    encontraCaminho(grafo, melhorCaminho);
    int distancia = 0; // Inicializa a variável que armazenará a distância total do caminho.
    // Calcula a distância total percorrida ao somar as distâncias entre as cidades do caminho.
    for (int i = 0; i < numCidades - 1; i++) {
        int cidadeOrigem = melhorCaminho[i];
        int cidadeDestino = melhorCaminho[i + 1];
        distancia += obterDistancia(grafo, cidadeOrigem, cidadeDestino);
    }
    // Adiciona a distância entre a última cidade e a cidade de origem para fechar o ciclo.
    distancia += obterDistancia(grafo, melhorCaminho[numCidades - 1], melhorCaminho[0]);
    //Imprime a lista de adjacencias
    imprimeOrdenado(grafo);
    // Imprime o caminho mais curto encontrado e a distância total.
    imprimeCaminho(grafo, melhorCaminho, distancia);
    // Libera a memória alocada para o vetor do melhor caminho.
    free(melhorCaminho);
    // Libera a memória alocada para o grafo.
    desalocarGrafo(grafo);
    return 0; // Retorna 0 para indicar que o programa foi executado com sucesso.
}
\end{lstlisting}
\section{Testes}
Os testes foram realizados com os arquivos disponibilizados pelo professor da disciplina. No caso
foram disponibilizados 5 arquivos com as entradas e 5 arquivos com as saídas esperadas. Para o
primeiro caso, as entradas sao
\begin{verbatim}
4
0 0 0 
0 1 10
0 2 15
0 3 20
1 0 10
1 1 0 
1 2 35
1 3 25
2 0 15
2 1 35
2 2 0
2 3 30
3 0 20
3 1 25
3 2 30
3 3 0
\end{verbatim}
e a saída esperada deve ser \begin{verbatim}
Adjacencias do vertice 0: (0, 0) -> (1, 10) -> (2, 15) -> (3, 20) -> NULL
Adjacencias do vertice 1: (1, 0) -> (0, 10) -> (3, 25) -> (2, 35) -> NULL
Adjacencias do vertice 2: (2, 0) -> (0, 15) -> (3, 30) -> (1, 35) -> NULL
Adjacencias do vertice 3: (3, 0) -> (0, 20) -> (1, 25) -> (2, 30) -> NULL
Melhor caminho: 0 1 3 2 0
Melhor distancia: 80
\end{verbatim}
Para o segundo caso, as entradas sao˜
\begin{verbatim} 
6
0 0 0 
0 1 1 
0 2 2 
0 3 1
0 4 1
0 5 2
1 0 1
1 1 0
1 2 7
1 3 1 
1 4 4
1 5 3
2 0 2 
2 1 7
2 2 0 
2 3 3 
2 4 1
2 5 1
3 0 1 
3 1 1 
3 2 3 
3 3 0
3 4 8 
3 5 1
4 0 1 
4 1 2 
4 2 1 
4 3 8
4 4 0
4 5 1
5 0 2
5 1 3
5 2 1 
5 3 1 
5 4 1
5 5 0
\end{verbatim}
e a saída esperada deve ser \begin{verbatim} 
Adjacencias do vertice 0: (0, 0) -> (1, 1) -> (3, 1) -> (4, 1) -> (2, 2) -> (5, 2) -> NULL
Adjacencias do vertice 1: (1, 0) -> (0, 1) -> (3, 1) -> (5, 3) -> (4, 4) -> (2, 7) -> NULL
Adjacencias do vertice 2: (2, 0) -> (4, 1) -> (5, 1) -> (0, 2) -> (3, 3) -> (1, 7) -> NULL
Adjacencias do vertice 3: (3, 0) -> (0, 1) -> (1, 1) -> (5, 1) -> (2, 3) -> (4, 8) -> NULL
Adjacencias do vertice 4: (4, 0) -> (0, 1) -> (2, 1) -> (5, 1) -> (1, 2) -> (3, 8) -> NULL
Adjacencias do vertice 5: (5, 0) -> (2, 1) -> (3, 1) -> (4, 1) -> (0, 2) -> (1, 3) -> NULL
Melhor caminho: 0 1 3 5 2 4 0
Melhor distancia: 6
\end{verbatim}
Para o terceiro caso, as entradas são
\begin{verbatim}
4
0 0 0
0 1 1 
0 2 1 
0 3 3 
1 0 1
1 1 0
1 2 4
1 3 5
2 0 1
2 1 4 
2 2 0 
2 3 6
3 0 3 
3 1 5 
3 2 6 
3 3 0
\end{verbatim}
e a saída esperada deve ser 
\begin{verbatim}
Adjacencias do vertice 0: (0, 0) -> (1, 1) -> (2, 1) -> (3, 3) -> NULL
Adjacencias do vertice 1: (1, 0) -> (0, 1) -> (2, 4) -> (3, 5) -> NULL
Adjacencias do vertice 2: (2, 0) -> (0, 1) -> (1, 4) -> (3, 6) -> NULL
Adjacencias do vertice 3: (3, 0) -> (0, 3) -> (1, 5) -> (2, 6) -> NULL
Melhor caminho: 0 1 3 2 0 
Melhor distancia: 13
\end{verbatim}
Para o quarto caso, as entradas são
\begin{verbatim}
5 
0 0 0 
0 1 2 
0 2 0
0 3 3
0 4 6
1 0 2 
1 1 0
1 2 4 
1 3 3
1 4 0
2 0 0
2 1 4
2 2 0
2 3 7
2 4 3
3 0 3 
3 1 3
3 2 7
3 3 0
3 4 3
4 0 6
4 1 0
4 2 3
4 3 3
4 4 0
\end{verbatim}
e a saída esperada deve ser
\begin{verbatim}
Adjacencias do vertice 0: (0, 0) -> (2, 0) -> (1, 2) -> (3, 3) -> (4, 6) -> NULL
Adjacencias do vertice 1: (1, 0) -> (4, 0) -> (0, 2) -> (3, 3) -> (2, 4) -> NULL
Adjacencias do vertice 2: (0, 0) -> (2, 0) -> (4, 3) -> (1, 4) -> (3, 7) -> NULL
Adjacencias do vertice 3: (3, 0) -> (0, 3) -> (1, 3) -> (4, 3) -> (2, 7) -> NULL
Adjacencias do vertice 4: (1, 0) -> (4, 0) -> (2, 3) -> (3, 3) -> (0, 6) -> NULL
Melhor caminho: 0 1 2 4 3 0 
Melhor distancia: 15
\end{verbatim}
Para o quinto caso, as entradas sao
\begin{verbatim}
5 
0 0 0
0 1 5
0 2 10
0 3 0
0 4 1
1 0 5
1 1 0
1 2 0 
1 3 10
1 4 1
2 0 10
2 1 0
2 2 0
2 3 2
2 4 1
3 0 0 
3 1 10
3 2 2
3 3 0
3 4 1
4 0 1
4 1 1
4 2 1
4 3 1
4 4 0
\end{verbatim}
e a saída esperada deve ser
\begin{verbatim}
Adjacencias do vertice 0: (0, 0) -> (3, 0) -> (4, 1) -> (1, 5) -> (2, 10) -> NULL
Adjacencias do vertice 1: (1, 0) -> (2, 0) -> (4, 1) -> (0, 5) -> (3, 10) -> NULL
Adjacencias do vertice 2: (1, 0) -> (2, 0) -> (4, 1) -> (3, 2) -> (0, 10) -> NULL
Adjacencias do vertice 3: (0, 0) -> (3, 0) -> (4, 1) -> (2, 2) -> (1, 10) -> NULL
Adjacencias do vertice 4: (4, 0) -> (0, 1) -> (1, 1) -> (2, 1) -> (3, 1) -> NULL
Melhor caminho: 0 1 3 2 4 0 
Melhor distancia: 19
\end{verbatim}
O programa atendeu a todos os testes, menos ao teste 5 que retorna o melhor caminho como 0 4 2 3 1 0, sendo que deveria ser  0 1 3 2 4 0. Todavia, após conversa com o professor da disciplina foi decidido que poderia ficar assim mesmo, que não haveria perca de pontos pois todo o resto está certo.
\section{Análise}
Nesse programa, assim como no trabalho anterior, foi implementada uma abordagem de força bruta utilizando recursividade para encontrar o caminho mais curto, o que
significa que ele explora todas as possíveis combinações de cidades para encontrar a solução. Esse trabalho trouxe um nível de dificuldade um pouco maior por ter que utilizar listas encadeadas, mas possuí a mesma questão do primeiro trabalho por usar recursividade. Para conjuntos de cidades pequenos, a abordagem utilizando recursividade pode ser aceitável e fornecer soluções precisas. No entanto, para um grande número de cidades, a execução do programa pode levar um tempo impraticável, tornando-o ineficiente. Para resolver o problema de forma eficiente em conjuntos de cidades maiores, seriam necessárias abordagens mais sofisticadas, como algoritmos baseados em heurísticas. Esse trabalho demonstra a complexidade dos testes quando levados a um número maior de entradas. Com isso, prova-se a importância da análise de complexidades.
\section{Considerações Finais}
Desenvolver esse trabalho foi bem significante para mim, pois aprimorou meu conhecimento sobre funções recursivas, ordenação e listas encadeadas. Além da dificuldade do trabalho anterior de ter que desenvolver o trabalho sozinho tive a dificuldade de ter que fazer o trabalho pós operado, o que foi bem desgastante para mim. Fora isso, gostei bastante de fazer o trabalho e conclui-lo é bem gratificante para mim.
\bibliographystyle{plain}
\bibliography{refs}
CELES,Waldemar; CERQUEIRA,Renato; RANGEL,Jose Lucas. Introdução a Estruturas de
Dados: com técnicas de programação em C.. Rio de Janeiro: Elsevier 2004. 293 p.
\end{document}